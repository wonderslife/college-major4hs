# Dispatching Parallel Agents - 调度并行代理

## 简介

Dispatching Parallel Agents skill用于在面临2+个可以在没有共享状态或顺序依赖的情况下工作的独立任务时使用。核心原则：**每个独立问题域分派一个代理。让它们并发工作。**

## 使用场景

**使用当：**
- 3+个测试文件失败，具有不同的根本原因
- 多个子系统独立损坏
- 每个问题可以在没有其他上下文的情况下理解
- 调查之间没有共享状态

**不使用当：**
- 失败相关（修复一个可能修复其他）
- 需要理解完整系统状态
- 代理会互相干扰

## 模式

### 1. 识别独立域

按损坏的内容分组失败：
- 文件A测试：工具批准流程
- 文件B测试：批完成行为
- 文件C测试：中止功能

每个域是独立的 - 修复工具批准不影响中止测试。

### 2. 创建聚焦的代理任务

每个代理获得：
- **特定范围**：一个测试文件或子系统
- **清晰目标**：使这些测试通过
- **约束**：不要更改其他代码
- **预期输出**：你发现和修复的摘要

### 3. 并行分派

```typescript
// 在Claude Code / AI环境中
Task("Fix agent-tool-abort.test.ts failures")
Task("Fix batch-completion-behavior.test.ts failures")
Task("Fix tool-approval-race-conditions.test.ts failures")
// 三个都并发运行
```

### 4. 审阅和集成

当代理返回时：
- 阅读每个摘要
- 验证修复不冲突
- 运行完整测试套件
- 集成所有更改

## 代理提示结构

好的代理提示是：
1. **聚焦** - 一个清晰的问题域
2. **自包含** - 理解问题所需的所有上下文
3. **关于输出的具体** - 代理应该返回什么？

```markdown
修复src/agents/agent-tool-abort.test.ts中的3个失败测试：

1. "should abort tool with partial output capture" - 期望消息中有'interrupted at'
2. "should handle mixed completed and aborted tools" - 快速工具被中止而不是完成
3. "should properly track pendingToolCount" - 期望3个结果但得到0

这些是时序/竞争条件问题。你的任务：

1. 阅读测试文件并理解每个测试验证什么
2. 识别根本原因 - 时序问题还是实际bug？
3. 通过以下方式修复：
   - 用基于事件的等待替换任意超时
   - 如果发现，修复中止实现中的bug
   - 如果测试更改的行为，调整测试期望

不要只是增加超时 - 找到真正的问题。

返回：你发现和修复的摘要。
```

## 常见错误

**❌ 太宽泛：** "修复所有测试" - 代理迷失
**✅ 具体：** "修复agent-tool-abort.test.ts" - 聚焦范围

**❌ 没有上下文：** "修复竞争条件" - 代理不知道在哪里
**✅ 上下文：** 粘贴错误消息和测试名称

**❌ 没有约束：** 代理可能重构所有东西
**✅ 约束：** "不要更改生产代码"或"仅修复测试"

**❌ 模糊输出：** "修复它" - 你不知道什么改变了
**✅ 具体：** "返回根本原因和更改的摘要"

## 何时不使用

**相关失败：** 修复一个可能修复其他 - 首先一起调查
**需要完整上下文：** 理解需要看到整个系统
**探索性调试：** 你还不知道什么坏了
**共享状态：** 代理会干扰（编辑相同文件、使用相同资源）

## 现实示例

**场景：** 主要重构后6个测试失败跨3个文件

**失败：**
- agent-tool-abort.test.ts：3个失败（时序问题）
- batch-completion-behavior.test.ts：2个失败（工具不执行）
- tool-approval-race-conditions.test.ts：1个失败（执行计数= 0）

**决策：** 独立域 - 中止逻辑与批完成分离，与竞争条件分离

**分派：**
```
代理1 → 修复agent-tool-abort.test.ts
代理2 → 修复batch-completion-behavior.test.ts
代理3 → 修复tool-approval-race-conditions.test.ts
```

**结果：**
- 代理1：用基于事件的等待替换超时
- 代理2：修复事件结构bug（threadId在错误的地方）
- 代理3：添加等待以完成异步工具执行

**集成：** 所有修复独立，无冲突，完整套件绿色

**节省的时间：** 并行解决3个问题 vs 顺序

## 关键好处

1. **并行化** - 多个调查同时发生
2. **聚焦** - 每个代理有窄范围，更少上下文要跟踪
3. **独立性** - 代理不互相干扰
4. **速度** - 在1个的时间内解决3个问题

## 验证

代理返回后：
1. **审阅每个摘要** - 理解什么改变了
2. **检查冲突** - 代理编辑了相同代码吗？
3. **运行完整套件** - 验证所有修复一起工作
4. **抽查** - 代理可能犯系统性错误

## 现实世界影响

从调试会话（2025-10-03）：
- 6个失败跨3个文件
- 3个代理并行分派
- 所有调查并发完成
- 所有修复成功集成
- 代理更改之间零冲突
