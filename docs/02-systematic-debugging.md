# Systematic Debugging - 系统化调试

## 简介

Systematic Debugging skill用于在遇到任何bug、测试失败或意外行为时，通过系统化的方法找到根本原因后再进行修复。核心原则：**总是先找到根本原因，再尝试修复**。

## 使用场景

- 测试失败
- 生产环境bug
- 意外行为
- 性能问题
- 构建失败
- 集成问题

## 四个阶段

### 阶段1：根本原因调查

**在尝试任何修复之前：**

1. **仔细阅读错误消息**
   - 不要跳过错误或警告
   - 它们通常包含确切的解决方案
   - 完整阅读堆栈跟踪
   - 记录行号、文件路径、错误代码

2. **一致地重现**
   - 能可靠地触发它吗？
   - 确切的步骤是什么？
   - 每次都会发生吗？
   - 如不可重现 → 收集更多数据，不要猜测

3. **检查最近的更改**
   - 什么更改可能导致这个问题？
   - Git diff，最近的提交
   - 新依赖、配置更改
   - 环境差异

4. **在多组件系统中收集证据**

   **当系统有多个组件（CI → build → signing, API → service → database）时：**

   **在提出修复之前，添加诊断工具：**
   ```
   对于每个组件边界：
     - 记录进入组件的数据
     - 记录退出组件的数据
     - 验证环境/配置传播
     - 检查每层的状态

   运行一次以收集证据显示在哪里失败
   然后分析证据以识别失败的组件
   然后调查该特定组件
   ```

5. **追踪数据流**

   **当错误深在调用堆栈中：**

   - 坏值从哪里来？
   - 什么用坏值调用了这个？
   - 继续向上追踪直到找到源头
   - 在源头修复，而不是在症状处

### 阶段2：模式分析

**在修复之前找到模式：**

1. **找到工作示例**
   - 在相同代码库中定位类似的工作代码
   - 什么工作类似于坏的？

2. **与参考进行比较**
   - 如实现模式，完整阅读参考实现
   - 不要略读 - 阅读每一行
   - 在应用之前完全理解模式

3. **识别差异**
   - 工作和坏之间有什么不同？
   - 列出每个差异，无论多小
   - 不要假设"这不可能重要"

4. **理解依赖**
   - 这需要什么其他组件？
   - 什么设置、配置、环境？
   - 它做出什么假设？

### 阶段3：假设和测试

**科学方法：**

1. **形成单一假设**
   - 清楚地陈述："我认为X是根本原因，因为Y"
   - 写下来
   - 具体，不模糊

2. **最小化测试**
   - 做最小可能的更改来测试假设
   - 一次一个变量
   - 不要一次修复多个东西

3. **在继续之前验证**
   - 有效吗？是 → 阶段4
   - 无效？形成新假设
   - 不要在上面添加更多修复

4. **当你不知道时**
   - 说"我不理解X"
   - 不要假装知道
   - 寻求帮助
   - 研究更多

### 阶段4：实现

**修复根本原因，不是症状：**

1. **创建失败的测试用例**
   - 最简单的可能的重现
   - 自动化测试（如果可能）
   - 如无框架，一次性测试脚本
   - 必须在修复之前有

2. **实现单一修复**
   - 解决识别的根本原因
   - 一次一个更改
   - 没有"既然我在这里"的改进
   - 没有捆绑重构

3. **验证修复**
   - 测试现在通过吗？
   - 没有其他测试坏掉？
   - 问题实际解决了吗？

4. **如果修复无效**
   - 停止
   - 计数：你尝试了多少次修复？
   - 如 < 3：返回阶段1，用新信息重新分析
   - **如 ≥ 3：停止并质疑架构（步骤5）**
   - 不要在没有架构讨论的情况下尝试修复 #4

5. **如果3+次修复失败：质疑架构**

   **指示架构问题的模式：**
   - 每次修复揭示不同地方的新的共享状态/耦合/问题
   - 修复需要"大规模重构"来实现
   - 每次修复在其他地方创建新症状

   **停止并质疑基础：**
   - 这个模式根本合理吗？
   - 我们是否"纯粹通过惯性坚持它"？
   - 我们应该重构架构 vs 继续修复症状？

## 红旗 - 停止并遵循流程

如果你发现自己思考：
- "现在快速修复，稍后调查"
- "只是尝试更改X看看是否有效"
- "添加多个更改，运行测试"
- "跳过测试，我会手动验证"
- "可能是X，让我修复它"
- "我不完全理解但这可能有效"
- "模式说X但我会不同地适应它"
- "这是主要问题：[列出没有调查的修复]"
- 在追踪数据流之前提出解决方案
- **"再尝试一次修复"（当已经尝试2+次）**
- **每次修复在不同地方揭示新问题**

**所有这些意味着：停止。返回阶段1。**

## 常见合理化

| 借口 | 现实 |
|--------|---------|
| "问题简单，不需要流程" | 简单问题也有根本原因。简单bug的流程很快。 |
| "紧急，没有时间流程" | 系统化调试比猜测和检查thrashing更快。 |
| "先尝试这个，然后调查" | 第一次修复设定模式。从一开始就做对。 |
| "确认修复有效后我会写测试" | 未经测试的修复不坚持。测试先证明它。 |
| "一次多个更改节省时间" | 无法隔离什么有效。导致新bug。 |
| "参考太长，我会适应模式" | 部分理解保证bug。完整阅读它。 |
| "我看到问题，让我修复它" | 看到症状 ≠ 理解根本原因。 |
| "再尝试一次修复"（2+次失败后） | 3+次失败 = 架构问题。质疑模式，不要再次修复。 |

## 快速参考

| 阶段 | 关键活动 | 成功标准 |
|-------|---------------|------------------|
| **1. 根本原因** | 阅读错误，重现，检查更改，收集证据 | 理解什么和为什么 |
| **2. 模式** | 找到工作示例，比较 | 识别差异 |
| **3. 假设** | 形成理论，最小化测试 | 确认或新假设 |
| **4. 实现** | 创建测试，修复，验证 | Bug解决，测试通过 |

## 人类伙伴的信号表明你做错了

**注意这些重定向：**
- "那不是发生吗？" - 你假设而没有验证
- "它会向我们展示...？" - 你应该已经添加证据收集
- "停止猜测" - 你在没有理解的情况下提出修复
- "超级思考这个" - 质疑基础，不仅仅是症状
- "我们卡住了？"（沮丧） - 你的方法不工作

**当你看到这些时：** 停止。返回阶段1。

## 现实世界影响

从调试会话：
- 系统化方法：15-30分钟修复
- 随机修复方法：2-3小时thrashing
- 首次修复率：95% vs 40%
- 引入的新bug：接近零 vs 常见
