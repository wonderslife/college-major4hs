# Subagent-Driven Development - 子代理驱动开发

## 简介

Subagent-Driven Development skill用于在当前会话中通过为每个任务分派新的子代理来执行实施计划，每个任务后进行两阶段审查：先规范符合性审查，然后代码质量审查。

## 使用场景

- 有实施计划，任务大多是独立的
- 在同一会话中执行（无上下文切换）
- 需要快速迭代（无人工在循环中）
- 每个任务需要新鲜上下文（无上下文污染）

## 核心流程

### 每个任务的流程

```
1. 分派实现子代理（./implementer-prompt.md）
2. 实现子代理问问题吗？
   → 是：回答问题，提供上下文
   → 否：继续
3. 实现子代理实施、测试、提交、自审阅
4. 分派规范审查子代理（./spec-reviewer-prompt.md）
5. 规范审查子代理确认代码符合规范吗？
   → 否：实现子代理修复规范缺口
   → 是：继续
6. 分派代码质量审查子代理（./code-quality-reviewer-prompt.md）
7. 代码质量审查子代理批准吗？
   → 否：实现子代理修复质量问题
   → 是：在TodoWrite中标记任务完成
```

### 所有任务完成后

```
8. 为整个实施分派最终代码审查子代理
9. 使用superpowers:finishing-a-development-branch
```

## 优势

### vs 手动执行
- 子代理自然遵循TDD
- 每个任务有新鲜上下文（无困惑）
- 并行安全（子代理不干扰）
- 子代理可以在之前和期间问问题

### vs 执行计划
- 同一会话（无交接）
- 连续进度（无等待）
- 审查检查点自动

## 效率增益

- 无文件读取开销（控制器提供完整文本）
- 控制器策展恰好需要什么上下文
- 子代理预先获得完整信息
- 问题在工作开始前浮现（而不是之后）

## 质量门

- 自审阅在交接前捕获问题
- 两阶段审查：规范符合性，然后代码质量
- 审查循环确保修复实际有效
- 规范符合性防止过度/不足构建
- 代码质量确保实施良好

## 成本

- 更多子代理调用（每个任务：实现 + 2个审查者）
- 控制器做更多准备工作（预先提取所有任务）
- 审查循环添加迭代
- 但早期捕获问题（比稍后调试更便宜）

## 红旗

**从不：**
- 跳过审查（规范符合性或代码质量）
- 用未修复的问题继续
- 并行分派多个实现子代理（冲突）
- 让子代理阅读计划文件（提供完整文本代替）
- 跳过场景设置上下文（子代理需要理解任务适合哪里）
- 忽略子代理问题
- 接受规范符合性的"足够接近"（规范审查者发现问题 = 未完成）
- 跳过审查循环（审查者发现问题 = 实现者修复 = 再次审查）
- **在规范符合性✅之前开始代码质量审查**（错误顺序）
- 当任一审查有开放问题时移动到下一个任务

## 集成

**必需的工作流技能：**
- **superpowers:writing-plans** - 创建此skill执行的计划
- **superpowers:requesting-code-review** - 审查者子代理的代码审查模板
- **superpowers:finishing-a-development-branch** - 所有任务完成后完成开发

**子代理应该使用：**
- **superpowers:test-driven-development** - 子代理为每个任务遵循TDD

**替代工作流：**
- **superpowers:executing-plans** - 用于并行会话而不是同一会话执行
