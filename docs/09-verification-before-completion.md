# Verification Before Completion - 完成前验证

## 简介

Verification Before Completion skill用于在声称工作完成、修复或通过之前，要求运行验证命令并确认输出后再做出任何成功声明。核心原则：**证据先于断言，总是如此。**

## 使用场景

**总是在以下情况之前使用：**
- 任何成功/完成声明的变体
- 任何满意的表达
- 关于工作状态的任何积极陈述
- 提交、PR创建、任务完成
- 移动到下一个任务
- 委托给代理

## 核心流程

### 门控函数

```
在声称任何状态或表达满意之前：

1. 识别：什么命令证明这个声明？
2. 运行：执行完整命令（新鲜、完整）
3. 阅读：完整输出，检查退出代码，计数失败
4. 验证：输出确认声明吗？
   - 如果否：用证据陈述实际状态
   - 如果是：用证据陈述声明
5. 只有这样：做出声明

跳过任何步骤 = 撒谎，不是验证
```

## 常见失败

| 声明 | 需要 | 不充分 |
|-------|----------|----------------|
| 测试通过 | 测试命令输出：0次失败 | 之前运行，"应该通过" |
| Linter清洁 | Linter输出：0个错误 | 部分检查，外推 |
| 构建成功 | 构建命令：退出0 | Linter通过，日志看起来不错 |
| Bug修复 | 测试原始症状：通过 | 代码更改，假设修复 |
| 回归测试工作 | 红绿循环验证 | 测试通过一次 |
| 代理完成 | VCS diff显示更改 | 代理报告"成功" |
| 要求满足 | 逐行检查表 | 测试通过 |

## 红旗 - 停止

- 使用"应该"、"可能"、"似乎"
- 在验证之前表达满意（"好！"、"完美！"、"完成！"等）
- 即将提交/推送/PR而没有验证
- 信任代理成功报告
- 依赖部分验证
- 思考"就这一次"
- 疲劳并希望工作结束
- **任何暗示成功而没有运行验证的措辞**

## 合理化预防

| 借口 | 现实 |
|--------|---------|
| "现在应该工作" | 运行验证 |
| "我有信心" | 信心 ≠ 证据 |
| "就这一次" | 没有例外 |
| "Linter通过" | Linter ≠ 编译器 |
| "代理说成功" | 独立验证 |
| "我累了" | 疲劳 ≠ 借口 |
| "部分检查足够" | 部分什么都不证明 |
| "不同词语所以规则不适用" | 精神高于字母 |

## 关键模式

### 测试
```
✅ [运行测试命令] [看到：34/34通过] "所有测试通过"
❌ "现在应该通过" / "看起来正确"
```

### 回归测试（TDD红绿）
```
✅ 编写 → 运行（通过） → 撤销修复 → 运行（必须失败） → 恢复 → 运行（通过）
❌ "我已经写了回归测试"（没有红绿验证）
```

### 构建
```
✅ [运行构建] [看到：退出0] "构建通过"
❌ "Linter通过"（linter不检查编译）
```

### 要求
```
✅ 重新阅读计划 → 创建检查表 → 验证每个 → 报告缺口或完成
❌ "测试通过，阶段完成"
```

### 代理委派
```
✅ 代理报告成功 → 检查VCS diff → 验证更改 → 报告实际状态
❌ 信任代理报告
```

## 为什么这很重要

从24次失败记忆：
- 你的伙伴说"我不相信你" - 信任被破坏
- 未定义的函数被运送 - 会崩溃
- 缺失的要求被运送 - 不完整的功能
- 在虚假完成上浪费时间 → 重定向 → 重新工作
- 违反："诚实是核心价值。如果你撒谎，你将被替换。"

## 何时应用

**总是在之前：**
- 任何成功/完成声明的变体
- 任何满意的表达
- 关于工作状态的任何积极陈述
- 提交、PR创建、任务完成
- 移动到下一个任务
- 委托给代理

**规则适用于：**
- 确切短语
- 改写和同义词
- 成功的暗示
- 任何建议完成/正确性的沟通

## 底线

**验证没有捷径。**

运行命令。阅读输出。然后声称结果。

这是不可协商的。
